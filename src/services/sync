/**
 * Route Sync Service
 *
 * Polls Spoke API every 15 minutes (8 AM – 6 PM EST, Mon–Fri) to catch:
 *   - Stops added after the initial "send route to driver" webhook
 *   - Stops that were missing data (phone, sale number) at webhook time
 *   - Stops whose fields were updated in Spoke after import
 *
 * Also provides a manual sync endpoint for the dashboard.
 *
 * FLOW:
 *   1. GET /teams → discover team ID (cached)
 *   2. GET /teams/{teamId}/plans → get today's + tomorrow's plans
 *   3. For each plan → GET /plans/{planId}/stops → all stops
 *   4. For each delivery stop:
 *      - Not in DB → import as pending notification
 *      - In DB as pending + was missing phone → update with new data
 *      - In DB as pending + data changed → update
 */

const db = require("../database");
const fetch = require("node-fetch");
const { computeDeliveryWindow, isDeliveryDay } = require("./templates");

const SPOKE_API_BASE = "https://api.getcircuit.com/public/v0.2b";
const SYNC_INTERVAL_MS = 15 * 60 * 1000; // 15 minutes
const SYNC_START_HOUR = 8;  // 8 AM EST
const SYNC_END_HOUR = 18;   // 6 PM EST

let cachedTeamId = null;

// ─── Sale Number → Store (same mapping as spoke.js) ──────
const SALE_PREFIX_TO_STORE = {
  "1": "other",
  "2": "lexington",
  "3": "georgetown",
  "4": "somerset",
  "5": "london",
};

const STORE_DISPLAY_NAMES = {
  somerset: "Mattress Overstock - Somerset",
  lexington: "Mattress Overstock - Nicholasville Road",
  london: "Mattress Overstock - London",
  georgetown: "Mattress Overstock - Georgetown",
  other: "Mattress Overstock",
};

function resolveStoreFromSaleNumber(saleNumber) {
  if (!saleNumber) return "unknown";
  const prefix = String(saleNumber).charAt(0);
  return SALE_PREFIX_TO_STORE[prefix] || "unknown";
}

function extractSaleNumber(customProperties) {
  if (!customProperties || typeof customProperties !== "object") return null;
  const byName =
    customProperties["Sale Number"] ||
    customProperties["sale_number"] ||
    customProperties["saleNumber"] ||
    customProperties["Sale number"] ||
    customProperties["sale number"] ||
    null;
  if (byName) return byName;

  const values = Object.values(customProperties);
  if (values.length > 0 && values[0]) return values[0];
  return null;
}

function cleanPhone(phone) {
  if (!phone) return "";
  let cleaned = phone.replace(/[^\d+]/g, "");
  if (cleaned.length === 10) cleaned = "+1" + cleaned;
  if (cleaned.length === 11 && cleaned.startsWith("1")) cleaned = "+" + cleaned;
  return cleaned;
}

function logActivity(type, detail, notificationId = null) {
  db.prepare("INSERT INTO activity_log (type, detail, notification_id, created_at) VALUES (?, ?, ?, ?)").run(
    type, detail, notificationId, new Date().toISOString()
  );
}

function getESTNow() {
  return new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
}

function parseDateFromRouteTitle(title) {
  if (!title) return null;
  try {
    const match = title.match(/(\w+),\s+(\w+)\s+(\d+)/);
    if (match) {
      const months = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };
      const month = months[match[2]];
      if (month !== undefined) {
        const day = parseInt(match[3], 10);
        const year = new Date().getFullYear();
        const date = new Date(year, month, day);
        return date.toISOString().split("T")[0];
      }
    }
  } catch (e) {}
  return null;
}

// ─── Spoke API Helpers ───────────────────────────────────

async function spokeGet(path) {
  const apiKey = process.env.SPOKE_API_KEY;
  if (!apiKey) {
    console.log("[Sync] No SPOKE_API_KEY set");
    return null;
  }

  const url = path.startsWith("http") ? path : `${SPOKE_API_BASE}/${path}`;

  try {
    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
    });

    if (!res.ok) {
      console.error("[Sync] API error:", res.status, res.statusText, "for", path);
      return null;
    }

    return await res.json();
  } catch (err) {
    console.error("[Sync] Fetch error:", err.message);
    return null;
  }
}

async function getTeamId() {
  if (cachedTeamId) return cachedTeamId;

  const teams = await spokeGet("teams");
  if (!teams || !Array.isArray(teams) || teams.length === 0) {
    // Try alternate response shape
    if (teams?.teams && teams.teams.length > 0) {
      cachedTeamId = teams.teams[0].id;
    } else if (teams?.id) {
      cachedTeamId = teams.id;
    } else {
      console.error("[Sync] Could not discover team ID. Response:", JSON.stringify(teams)?.substring(0, 300));
      return null;
    }
  } else {
    cachedTeamId = teams[0].id;
  }

  console.log("[Sync] Team ID:", cachedTeamId);
  return cachedTeamId;
}

/**
 * Get plans for a date range.
 * Spoke API: GET /teams/{teamId}/plans?filter=date&start={ms}&end={ms}
 */
async function getPlans(startDate, endDate) {
  const teamId = await getTeamId();
  if (!teamId) return [];

  const startMs = new Date(startDate + "T00:00:00").getTime();
  const endMs = new Date(endDate + "T23:59:59").getTime();

  const result = await spokeGet(`${teamId}/plans?filter=date&start=${startMs}&end=${endMs}`);

  if (!result) return [];

  // Could be array or { plans: [...] }
  if (Array.isArray(result)) return result;
  if (result.plans && Array.isArray(result.plans)) return result.plans;
  if (result.id) return [result]; // single plan
  return [];
}

/**
 * Get all stops for a plan
 */
async function getPlanStops(planId) {
  const result = await spokeGet(`${planId}/stops`);
  if (!result) return [];
  if (Array.isArray(result)) return result;
  if (result.stops && Array.isArray(result.stops)) return result.stops;
  return [];
}

/**
 * Get plan details (includes routes with driver info)
 */
async function getPlanDetails(planId) {
  return await spokeGet(planId);
}

// ─── Main Sync Logic ─────────────────────────────────────

async function syncRoutes() {
  const now = getESTNow();
  const today = now.toISOString().split("T")[0];
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const tomorrowStr = tomorrow.toISOString().split("T")[0];

  console.log("\n[Sync] ═══════════════════════════════════════");
  console.log(`[Sync] Route sync started at ${now.toLocaleTimeString()}`);
  console.log(`[Sync] Checking plans for ${today} and ${tomorrowStr}`);

  const results = { newStops: 0, updated: 0, skipped: 0, errors: [] };

  try {
    const plans = await getPlans(today, tomorrowStr);
    console.log(`[Sync] Found ${plans.length} plan(s)`);

    for (const plan of plans) {
      const planId = plan.id || plan;
      const planIdStr = typeof planId === "string" ? planId : `plans/${planId}`;

      console.log(`[Sync] Processing plan: ${planIdStr}`);

      // Get plan details for route/driver info
      const planDetails = await getPlanDetails(planIdStr);

      // Build driver lookup from routes
      const driverMap = {};
      const routes = planDetails?.routes || [];
      for (const route of routes) {
        const routeId = route.id || route;
        if (route.driver) {
          if (typeof route.driver === "string" && route.driver.startsWith("drivers/")) {
            const driverData = await spokeGet(route.driver);
            if (driverData) {
              driverMap[routeId] = driverData.displayName || driverData.name || "Your driver";
            }
          } else if (typeof route.driver === "object") {
            driverMap[routeId] = route.driver.displayName || route.driver.name || "Your driver";
          }
        }
      }

      // Get all stops
      const stops = await getPlanStops(planIdStr);
      console.log(`[Sync] Plan has ${stops.length} stop(s)`);

      for (const stop of stops) {
        try {
          const result = await processStopForSync(stop, planDetails, driverMap);
          if (result === "new") results.newStops++;
          else if (result === "updated") results.updated++;
          else results.skipped++;
        } catch (err) {
          console.error(`[Sync] Error processing stop:`, err.message);
          results.errors.push(err.message);
        }
      }
    }
  } catch (err) {
    console.error("[Sync] Fatal error:", err.message);
    results.errors.push(err.message);
  }

  const summary = `Sync complete — ${results.newStops} new, ${results.updated} updated, ${results.skipped} unchanged`;
  console.log(`[Sync] ${summary}`);
  console.log("[Sync] ═══════════════════════════════════════\n");

  if (results.newStops > 0 || results.updated > 0) {
    logActivity("route_sync", summary);
  }

  return results;
}

/**
 * Process a single stop during sync.
 * Returns "new", "updated", or "skipped".
 */
async function processStopForSync(stop, planDetails, driverMap) {
  // Skip depot start/end
  if (stop.type === "start" || stop.type === "end") return "skipped";

  const stopId = stop.id || null;
  if (!stopId) return "skipped";

  // ─── Get recipient info ───
  const recipient = stop.recipient || {};
  const phone = recipient.phone || recipient.phoneNumber || recipient.mobile || null;
  const customerName =
    recipient.name ||
    recipient.displayName ||
    `${recipient.firstName || ""} ${recipient.lastName || ""}`.trim() ||
    null;

  // If the list endpoint strips PII, fetch the individual stop
  let fullStop = stop;
  if (!phone || !customerName) {
    fullStop = await spokeGet(stopId);
    if (!fullStop) return "skipped";
  }

  const fullRecipient = fullStop.recipient || {};
  const finalPhone = fullRecipient.phone || fullRecipient.phoneNumber || fullRecipient.mobile || phone;
  const finalName =
    fullRecipient.name ||
    fullRecipient.displayName ||
    `${fullRecipient.firstName || ""} ${fullRecipient.lastName || ""}`.trim() ||
    customerName ||
    "Unknown Customer";

  if (!finalPhone) return "skipped"; // Still no phone — nothing we can do

  // ─── Sale number + store ───
  const saleNumber = extractSaleNumber(fullStop.customProperties || stop.customProperties);
  const store = resolveStoreFromSaleNumber(saleNumber);

  // ─── Scheduled date ───
  let scheduledDate = null;
  const planTitle = planDetails?.title || "";
  if (planTitle) scheduledDate = parseDateFromRouteTitle(planTitle);

  // Try from plan date fields
  if (!scheduledDate && planDetails?.date) {
    scheduledDate = new Date(planDetails.date).toISOString().split("T")[0];
  }
  if (!scheduledDate) {
    const now = getESTNow();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    scheduledDate = tomorrow.toISOString().split("T")[0];
  }

  // ─── Validate delivery day ───
  const deliveryDate = new Date(scheduledDate + "T12:00:00");
  if (!isDeliveryDay(deliveryDate)) return "skipped";

  // ─── Address ───
  const addr = fullStop.address || stop.address || {};
  const address = addr.addressLineOne || addr.address || "";

  // ─── Time window from ETA ───
  let rawDeliveryTime = null;
  let timeWindow = "TBD";
  const eta = fullStop.eta || stop.eta || {};
  const etaTimestamp = eta.estimatedArrivalAt || eta.estimatedEarliestArrivalAt || null;

  if (etaTimestamp) {
    const etaDate = new Date(etaTimestamp * 1000);
    const estString = etaDate.toLocaleString("en-US", { timeZone: "America/New_York" });
    const estDate = new Date(estString);
    const hours = estDate.getHours();
    const minutes = estDate.getMinutes();
    const totalMinutes = hours * 60 + minutes;
    rawDeliveryTime = `${hours}:${String(minutes).padStart(2, "0")}`;
    const window = computeDeliveryWindow(totalMinutes);
    timeWindow = window.windowText;
  }

  // ─── Product ───
  const product =
    fullStop.notes ||
    fullStop.orderInfo?.products?.join(", ") ||
    (saleNumber ? `Sale #${saleNumber}` : "") ||
    "";

  // ─── Driver ───
  const routeRef = stop.route?.id || stop.route || null;
  const driver = (routeRef && driverMap[routeRef]) || "Your driver";

  // ─── Check existing ───
  const existing = db.prepare("SELECT * FROM notifications WHERE spoke_stop_id = ?").get(stopId);

  if (existing) {
    // Already exists — check if we should update a pending notification with missing data
    if (existing.status !== "pending") return "skipped";

    const needsUpdate =
      (existing.phone === "" && finalPhone) ||
      (existing.customer_name === "Unknown Customer" && finalName !== "Unknown Customer") ||
      (existing.store === "unknown" && store !== "unknown") ||
      (existing.time_window === "TBD" && timeWindow !== "TBD");

    if (!needsUpdate) return "skipped";

    db.prepare(
      `UPDATE notifications
       SET customer_name = ?, phone = ?, store = ?, address = ?,
           time_window = ?, raw_delivery_time = ?, product = ?, driver = ?,
           updated_at = ?
       WHERE id = ?`
    ).run(
      finalName !== "Unknown Customer" ? finalName : existing.customer_name,
      finalPhone ? cleanPhone(finalPhone) : existing.phone,
      store !== "unknown" ? store : existing.store,
      address || existing.address,
      timeWindow !== "TBD" ? timeWindow : existing.time_window,
      rawDeliveryTime || existing.raw_delivery_time,
      product || existing.product,
      driver !== "Your driver" ? driver : existing.driver,
      new Date().toISOString(),
      existing.id
    );

    console.log(`[Sync] ✓ Updated notification #${existing.id} for ${finalName}`);
    logActivity("stop_updated", `Sync updated: ${finalName} — ${STORE_DISPLAY_NAMES[store] || store}`, existing.id);
    return "updated";
  }

  // ─── New stop — insert ───
  const cleanedPhone = cleanPhone(finalPhone);
  console.log(`[Sync] New stop: ${finalName} | ${cleanedPhone} | ${store} | ${scheduledDate} | ${timeWindow}`);

  const result = db
    .prepare(
      `INSERT INTO notifications
      (customer_name, phone, store, address, scheduled_date, time_window, raw_delivery_time, product, driver, status, spoke_stop_id, spoke_route_id, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?, ?, ?)`
    )
    .run(
      finalName,
      cleanedPhone,
      store,
      address,
      scheduledDate,
      timeWindow,
      rawDeliveryTime,
      product,
      driver,
      stopId,
      routeRef,
      new Date().toISOString(),
      new Date().toISOString()
    );

  const notificationId = result.lastInsertRowid;
  logActivity("stop_imported", `Sync imported: ${finalName} → ${STORE_DISPLAY_NAMES[store] || store} (${timeWindow})`, notificationId);
  console.log(`[Sync] ✓ Stored notification #${notificationId}`);
  return "new";
}

// ─── Auto-sync Timer ─────────────────────────────────────

let syncInterval = null;

function startAutoSync() {
  console.log(`[Sync] Auto-sync enabled — every 15 min, 8 AM – 6 PM EST (Mon–Fri)`);
  logActivity("sync_started", "Auto-sync initialized — 15 min interval, 8 AM – 6 PM EST");

  // Check immediately on startup
  checkAndSync();

  // Then check every 15 minutes
  syncInterval = setInterval(checkAndSync, SYNC_INTERVAL_MS);
}

async function checkAndSync() {
  const now = getESTNow();
  const hour = now.getHours();
  const day = now.getDay(); // 0=Sun, 6=Sat

  // Only sync Mon–Fri, 8 AM – 6 PM EST
  if (day === 0 || day === 6) return;
  if (hour < SYNC_START_HOUR || hour >= SYNC_END_HOUR) return;

  try {
    await syncRoutes();
  } catch (err) {
    console.error("[Sync] Auto-sync error:", err.message);
  }
}

module.exports = { syncRoutes, startAutoSync };
